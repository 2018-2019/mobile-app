


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Kotlin Lab-03 Classes + Collections",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Introduction to Kotlin Classes and Collections.</p>",
  "folder" : "book-03-classes-and-collections",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "#Objectives",
    "shortTitle": "Kotlin Lab-03 Classes + Collections",
    "contentMd" : "#Objectives\n\nIntroduction to Kotlin Classes and Collections. "
    },
  
    {
    "title": "# Writing Classes",
    "shortTitle": "01",
    "contentMd" : "# Writing Classes\n\nSome theory first!\n\n##Fields\n\nIn Kotlin, classes cannot have fields; they have properties:\n\n- *var* properties are mutable.\n- *val* properties cannot be changed.\n\n\n##Constructors\n\nA class in Kotlin can have a *primary constructor* and one or more *secondary constructors*.\n\n- A *primary constructor* is part of the class header and goes after the class name.  A few examples: \n\n~~~\nclass Person constructor(firstName: String) \n{\n\n}\n~~~\n\n~~~\nclass Person(firstName: String, lastName: String) \n{\n\n}\n~~~\n\n~~~\nclass Person(val firstName: String, val lastName: String) \n{\n\n}\n~~~\n\n- A *secondary constructor* is prefixed with the keyword *constructor*.  They are not very common in Kotlin.  An example:\n\n~~~\nclass Person { \n\n    constructor(parent: Person) { \n        parent.children.add(this) \n    }\n}\n~~~\n\n\n##getters and setters\n\nIn Kotlin, getters (val and var) and setters (var) are optional and are auto-generated if you do not create them in your program.\n\n"
    },
  
    {
    "title": "# Person Class",
    "shortTitle": "02",
    "contentMd" : "# Person Class\n\nFirst let's create a new project and then start writing a class, Person.\n\n\n##Run IntelliJ as an Administrator\n\nOn the college computers, don't run IntelliJ as normal.  Instead, run it as Adminisrator by right clicking on the App and selecting the option *Run as Administrator*.\n\n\n##New Project in IntelliJ\n\nIn IntelliJ, create a new project.  When the *New Project* window appears, remember to choose:\n\n- *Gradle* and \n- under *Additional Libraries and Frameworks*, check both *Java* and *Kotlin (Java)*.\n\nUse the following credentials for your new project:\n\n![](img/01.png)\n\nand ensure that the chosen location for your project is ok:\n\n![](img/02.png)\n\nGradle will start downloading required dependencies.\n\n\n##Create two new Kotlin classes\n\nRight click on the *src/main/kotlin* directory and, when the context menu appears, select *New* followed by *Kotlin Class/File*.\n\nWhen the window appears, enter the class name in the format of *packagename.classname* i.e. **ie.wit.classes.main** and click ok.\n\nUsing the same approach, create a second class called *Person*.\n\n\n##Person class\n\nStart with entering this code in the Person class i.e. a class definition with a primary constructor for Person that accepts two String parameters.\n\n~~~\nclass Person(val firstName: String, val lastName: String) {\n    \n}\n~~~\n\n\n##Main class\n\nIn your main class, enter the following code:\n\n~~~\nfun main(args: Array<String>) {\n\n    val person = Person(\"Joe\", \"Soap\")\n\n    println(\"First Name = ${person.firstName}\")\n    println(\"Surname = ${person.lastName}\")\n}\n~~~\n\nIn our main function, we instantiating a *person* object with a first name of Joe and a last name of Soap.  We are then printing out the contents of these properties.  Note that we are using String Templates that we looked at in lab02 to construct our output.\n\nRun this code and you should have the following output:\n\n![](img/03.png)\n\n\n##A recap on the val property\n\nDid you notice that we created both of the properties in Person as *val* fields. \n\nTry insert an update of the firstName field before we start printing out i.e.:\n\n![](img/04.png)\n\nWe get a syntax error.  *val* properties are immutable...i.e. they cannot be updated.  Delete this line of code and move onto the next step.\n\n"
    },
  
    {
    "title": "#Person Constrcutor",
    "shortTitle": "03",
    "contentMd" : "#Person Constrcutor\n\nWe will experiment a little here with the *primary constructor* of the Person class.\n\n\n##Person class changes\n\nYour Person class currently looks like this...the properties are declared in the primary constructor:\n\n~~~\nclass Person(val firstName: String, val lastName: String) {\n    \n}\n~~~\n\nFirst remove the property declarations to be part of the class i.e.:\n\n~~~\nclass Person() {\n    \n    val firstName: String\n    val lastName: String\n\n}\n~~~\n\nThis will generate an error, as they need to be initialised.  Now add constructor variables like so and use them to initialise the Person properties (note that prefixing constructor variables with an underscore is standard):\n\n~~~\nclass Person(_firstName : String, _lastName : String) {\n    \n    val firstName = _firstName\n    val lastName = _lastName\n\n}\n~~~\n\nNow try run the main function again...your output should be the same i.e.:\n\n![](img/03.png)\n\n\n##Constructor with varied parameters\n\nKotlin allows us to use *varied* parameters in *primary constrctors*.  If we default a value at constructor level, we can use optional parameters when instantiating objects.  We will try this out now.\n\nIn your main function, change the instantiation of the person object to be (i.e. only one parameter):\n\n~~~\n    val person = Person(\"Joe)\n~~~\n\nThis generates a syntax error:\n\n![](img/05.png)\n\nWe have not set up the Person class to have *varied* parameters yet.  We will do this now.  \n\nGive a default value for each property in the Person *primary constructor* i.e.:\n\n~~~\nclass Person(_firstName : String = \"UNKNOWN FIRSTNAME\", _lastName : String = \"UNKNOWN LASTNAME\") {\n\n    val firstName = _firstName\n    val lastName = _lastName\n\n}\n~~~\n\nNow the syntax error disappears and when we run the code, we should get the following output:\n\n![](img/06.png)\n\n\n##init block\n\nNow lets add the following *init* block that will run some code at object creation time:\n\n~~~\nclass Person(_firstName : String = \"UNKNOWN FIRSTNAME\", _lastName : String = \"UNKNOWN LASTNAME\") {\n\n    val firstName = _firstName\n    val lastName = _lastName\n\n    //initialisation block\n    init {\n        println(\"First Name = ${firstName}\")\n        println(\"Surname = ${lastName}\")\n    }\n\n}\n~~~\n\nReturn the the Main.kt class and delete the println statements.  Also add the two new object instantions with varying parameters e.g.:\n\n~~~\nfun main(args: Array<String>) {\n\n    val person = Person(\"Joe\")\n    val person2 = Person(\"Joe\", \"Murphy\")\n    val person3 = Person()\n\n}\n~~~\n\nWhen you run this code, you should have the following output (the println statements are now called from the *init* block):\n\n![](img/07.png)\n\n\n#val properties\n\nAll the properties and objects we created above are *val* i.e. can't be updated.  What if we want properties that can be updated?  We will do this in the next step when we talk about *getters* and *setters*.\n\n\n\n"
    },
  
    {
    "title": "#Person (getter and setter)",
    "shortTitle": "04",
    "contentMd" : "#Person (getter and setter)\n\nIn Kotlin, getters (val and var) and setters (var) are optional and are auto-generated if you do not create them in your program.\n\n\n##getters \n\nFor example, the Person code that we just wrote:\n\n~~~\nclass Person(_firstName : String = \"UNKNOWN FIRSTNAME\", _lastName : String = \"UNKNOWN LASTNAME\") {\n\n    val firstName = _firstName\n    val lastName = _lastName\n\n    //initialisation block\n    init {\n        println(\"First Name = ${firstName}\")\n        println(\"Surname = ${lastName}\")\n    }\n\n}\n~~~\n\nis equivalent to (note the explicit declaration of the getters):\n\n~~~\nclass Person(_firstName : String = \"UNKNOWN FIRSTNAME\", _lastName : String = \"UNKNOWN LASTNAME\") {\n\n    val firstName = _firstName\n        get() = field\n\n    val lastName = _lastName\n        get() = field\n\n    //initialisation block\n    init {\n        println(\"First Name = ${firstName}\")\n        println(\"Surname = ${lastName}\")\n    }\n\n}\n~~~\n\nAdd these getters into your code; IntelliJ will complain that they are redundant code...leave them there for the moment.\n\n\n##setters\n\nGetters apply to both *val* and *var* properties.  Whereas setters only apply to *var* properties.  \n\nIn your code, change *val* to *var* for both firstName and lastName property declarations. \n\nNow lets add a setter for the lastName field that will convert the last name to uppercase (place it just after the get() for this property):\n\n~~~\nvar lastName = _lastName\n        get() = field\n        //setter code:\n        set(value){\n            field = value.toUpperCase();\n         }\n\n\n~~~\n\nRun your code again...the setters is not called at object creation time...i.e. the surname *Murphy* is NOT all in capitals.  \n\nIn your main function, make the following changes:\n\n- update all the person objects to be *var* instead of *val*.\n- add the following lines of code as the last statements in your main function (to update the lastName and print it out):\n\n~~~\n    person2.lastName = \"flynn\"\n    println(\"Updated Person 2 Surname: ${person2.lastName}\")\n~~~\n\nRun your code again and you should have the following output, showing that the setter was called and has converted the updated name to capitals:\n\n![](img/08.png)\n\n"
    },
  
    {
    "title": "#Data Classes",
    "shortTitle": "05",
    "contentMd" : "#Data Classes\n\nData classes were created to solely to hold data (i.e. models).\n\nWe can use the data class prefix to simply create a data class.\n\nThe compiler automatically generates methods from the primary constructor such as:\n\n- equals()\n- hashCode()\n- toString()\n- copy()\n\nWe will experiment with a few of these generated methods in this step. \n\n\n##Rules for Data Classes\n\n- The primary constructor must have at least one parameter\n\n- The parameters of the primary constructor must be marked as either var or val\n\n- The class cannot be open, abstract, inner or sealed\n\n- The class may extend other classes or implement interfaces\n\n\n##New Class, Employee\n\nWe will experiment with Data classes by creating a new class, Employee.  Add the following code to it (note the keyword, *data* and also note that the parameters of the primary constructor are var):\n\n~~~\ndata class Employee(var firstName: String, var lastName: String) {\n\n}\n~~~\n\n\n##toString() and copy()\n\nIn your main function, comment out the lines of code in it and add four new lines of code i.e.:\n\n~~~\nfun main(args: Array<String>) {\n\n   // var person = Person(\"Joe\")\n   // var person2 = Person(\"Joe\", \"Murphy\")\n   // var person3 = Person()\n   // person2.lastName = \"flynn\"\n   // println(\"Updated Person 2 Surname: ${person2.lastName}\")\n\n    val employee1 = Employee(\"Mark\", \"Roche\")\n    val employee2 = employee1.copy(firstName = \"Clare\")\n    println(employee1)\n    println(employee2.toString())\n\n}\n~~~\n\nIn the above code, we used the generated *copy()* method to copy one employee contents into another (and replace the first name). \n\nRun the code.  You can see from the output that there is a toString generated to the Employee.class file:\n\n![](img/09.png)\n\n\n##copy(), equals(), hashCode()\n\nIn your main function, add a third employee object:\n\n~~~\n    val employee3 = employee1.copy()\n~~~\n\nand add the following code (to demonstrate the use and existance of the generated methods, hashCode and equals):\n\n~~~\n    println(\"employee1 hashcode = ${employee1.hashCode()}\")\n    println(\"employee2 hashcode = ${employee2.hashCode()}\")\n    println(\"employee3 hashcode = ${employee3.hashCode()}\")\n\n    if (employee1.equals(employee2))\n        println(\"employee1 is equal to employee2.\")\n    else\n        println(\"employee1 is not equal to employee2.\")\n\n    if (employee1.equals(employee3))\n        println(\"employee1 is equal to employee3.\")\n    else\n        println(\"employee1 is not equal to employee3.\")\n\n~~~\n\nWhen you run the code, you should have the following output:\n\n![](img/10.png)\n\nSave your work...we will start on a new project in the next step.\n\n"
    },
  
    {
    "title": "# Arrays",
    "shortTitle": "06",
    "contentMd" : "# Arrays\n\nIn this step, we will experiment with Kotlin Arrays.  Arrays in Kotlin can be created using *arrayOf()* or the *Array()* constructor.\n\nCreate a new IntelliJ project and call it collections-project.  In this project, create a new class called *main*. \n\n\n##Array - arrayOf()\n\nIn your Main class, enter the following code:\n\n~~~\nfun main(args: Array<String>) {\n\n  val myArray = arrayOf(4, 5, 6, 7)\n  println(myArray.asList())\n  println(myArray[2])\n\n}\n~~~\n\nWhen you run this code, you should have the following output:\n\n~~~\n[4, 5, 6, 7]\n6\n~~~\n\n\n##Array - mixed types\n\nAdd the following lines of code to the end of your main function:\n\n~~~\n    val myMixedArray = arrayOf(4, 5, 6, 7, \"mixed\", \"types\", \"allowed\")\n    println(myMixedArray.asList())\n    println(myMixedArray)\n~~~\n\nWhen you run this code, the last two lines of the output should be:\n\n~~~\n[4, 5, 6, 7, mixed, types, allowed]\n[Ljava.lang.Object;@721e0f4f\n~~~\n\nIn the last line of output, we are interested in the inferred type...Object!  Kotlion allows mixed type arrays.\n\n\n##Array - choosing a type\n\nAdd the following lines of code to the end of your main function:\n\n~~~\n    val intArray1    = intArrayOf(4, 5, 6, 7)\n    val intArray2    = arrayOf<Int>(4, 5, 6, 7)\n    val charArray    = charArrayOf('a', 'b', 'c', 'd')\n    val booleanArray = booleanArrayOf(true, false, true)\n\n    println(\"IntArray1 : ${intArray1.asList()} and is type ${intArray1.javaClass.typeName}\")\n    println(\"IntArray2 : ${intArray2.asList()} and is type ${intArray2.javaClass.typeName}\")\n    println(\"charArray : ${charArray.asList()} and is type ${charArray.javaClass.typeName}\")\n    println(\"booleanArray : ${booleanArray.asList()} and is type ${booleanArray.javaClass.typeName}\")\n~~~\n\nIn these lines of code, we are choosing the type of the array when we create it.\n\nWhen you run this code, the last four lines of the output should be:\n\n~~~\nIntArray1 : [4, 5, 6, 7] and is type int[]\nIntArray2 : [4, 5, 6, 7] and is type java.lang.Integer[]\ncharArray : [a, b, c, d] and is type char[]\nbooleanArray : [true, false, true] and is type boolean[]    \n~~~\n\n\n##Array - choosing a type - mixed array\n\nWhen choosing a type for our array, can we have a mixed array?  Let's try it.\n\nAdd the following two lines of code to the end of your main function:\n\n~~~\n    val mixedArray1 = intArrayOf(4, 5, 6, 7, \"will\",\"not\",\"compile\")\n    val mixedArray2 = arrayOf<Int>(4, 5, 6, 7,\"will\",\"not\",\"compile\")\n~~~\n\nThese will result in a syntax error.  So we cannot have a mixed array in this case!  Delete these two lines of code.\n\n\n##Arrays - using a constructor\n\nThe Array() constructor requires a size and a lambda function.  We will be using lambda functions a fair bit when we move into the Android Framework. \n\nAdd the following lines of code to the end of your main function (note that the second parameter is a lambda function...we will cover more on this later):\n\n~~~\n    val intArray = Array(6,  {i -> i * 2} )\n    println (\"Array using Constructor: ${intArray.asList()}\")\n~~~\n\nWhen you run this code, the last line of the output should be:\n\n~~~\nArray using Constructor: [0, 2, 4, 6, 8, 10]\n~~~\n\nLooking at the output, can you figure out what the Lambda function is doing?  Hint: **i** refers to the index.  \n\n"
    },
  
    {
    "title": "# Collections",
    "shortTitle": "07",
    "contentMd" : "# Collections\n\nUnlike many languages, Kotlin distinguishes between *mutable* and *immutable* collections (lists, sets, maps, etc).  Precise control over exactly when collections can be edited is useful for eliminating bugs, and for designing good APIs.\n\n- *immutable* - The Kotlin **List<>** type is an interface that provides read-only operations like *size*, *get* and so on.  Like in Java, it inherits from *Collection<>* and that in turn inherits from *Iterable<>*.  \n\n- *mutable* - Methods that change the list are added by the *MutableList<>* interface. \n\nWe will be focusing on the *List* type mainly in this module.\n\n\n##mutable list\n\nAdd the following lines of code to the end of your main function.  This code create a mutable list of fruit, adds an item, changes an item and removes an item:\n\n~~~\n    val fruit = mutableListOf(\"Banana\", \"Kiwifruit\", \"Mango\", \"Apple\")\n    println(\"Mutable List: ${fruit}\")\n\n    //add an item \n    fruit.add(\"Pear\")\n    println(\"Mutable List: ${fruit}\")\n\n    //update an item\n    fruit[1] = \"Orange\"\n    println(\"Mutable List: ${fruit}\")\n\n    //remove an item\n    fruit.removeAt(2)\n    println(\"Mutable List: ${fruit}\")\n~~~\n\nWhen you run this code, the last lines of the output should be:\n\n~~~\nMutable List: [Banana, Kiwifruit, Mango, Apple]\nMutable List: [Banana, Kiwifruit, Mango, Apple, Pear]\nMutable List: [Banana, Orange, Mango, Apple, Pear]\nMutable List: [Banana, Orange, Apple, Pear]\n~~~\n\n\n##immutable list\n\nAdd the following lines of code to the end of your main function:\n\n~~~\n    val mutableNumbers: MutableList<Int> = mutableListOf(1, 2, 3)\n    val readOnlyView: List<Int> = mutableNumbers\n\n    println(\"Mutable numbers: ${mutableNumbers}\")        // prints \"[1, 2, 3]\"\n    mutableNumbers.add(4)\n\n    println(\"Read only view: ${readOnlyView}\")   // prints \"[1, 2, 3, 4]\"\n~~~\n\nWhen you run this code, the last lines of the output should be:\n\n~~~\nMutable numbers: [1, 2, 3]\nRead only view: [1, 2, 3, 4]\n~~~\n\nThe immutable list can view any updates.  But it can't do any updates.  Try add this line of code to the end of the main function:\n\n~~~\n    readOnlyView.add(5)         // -> does not compile\n~~~\n\nIt will not compile as the *add* method is not allowed to run over immutable lists.  Delete this line of code now.\n\n\n##iterating over a collection\n\nIn the above code, we just printed out the entire contents of the lists.  If we wanted to iterate over the collection of *fruit* and, say, print each item on a new line, we could do it like so (add this at the end of your main method):\n\n~~~\n    //ITERATING\n    for(fruitItem in fruit)\n        println(fruitItem)\n~~~\n\nRun this code and you should have the each item stored in *fruit* printed on individual lines like so:\n\n~~~\nBanana\nOrange\nApple\nPear\n~~~\n\nSave your work and keep the project open.\n\n"
    },
  
    {
    "title": "# Lambdas",
    "shortTitle": "08",
    "contentMd" : "# Lambdas\n\nWe will be using lambdas a fair bit when we move into the Android framework.  We will familiarise ourselves with them a little before starting Android.\n\nSome points on Lambdas:\n\n- You can pass an anonymous function (a lambda) as a parameter of a function.\n\n- A lambda expression is always surrounded by curly braces.\n\n- Its parameters (if any) are declared before -> (parameter types may be omitted),\n\n- The body goes after -> (when present).\n\n- An implicit variable called “it” is created and refers to the lambda expression’s only argument.\n\n\n##Using Lambdas to Iterate over Collections\n\nIn the last step, we looked at Lists and also at iterating over them using the for-each loop e.g.:\n\n~~~\n    //DECLARING A MUTABLE LIST\n    val fruit = mutableListOf(\"Banana\", \"Kiwifruit\", \"Mango\", \"Apple\")\n\n    //ITERATING OVER THE LIST\n    for(fruitItem in fruit)\n        println(fruitItem)\n~~~\n\nIn this step, we will use Lamdbas to do some work on Lists for us.\n\nLeaving all code as is in the main function, add the following lines as the last statements in the function:\n\n~~~\n    println(\"\\nUsing Lambdas:\\n\")\n    fruit.forEach  {it -> println(it)}\n~~~\n\nThe last line of code uses the *fruit* list we previously created. Over the *fruit* list, it calls the *forEach* function, passing a lambda expression as its parameter.  *it* is an implicit variable created and is the lambda expressions only parameter.  In this case *it* refers to each item in fruits.  It then prints each item in *fruit*.\n\nRun this code and you should have these lines of code as the last on your console:\n\n~~~\nUsing Lambdas:\n\nBanana\nOrange\nApple\nPear\n~~~\n\nLet's make one more change to the last line...specifying *it* as the parameter to the lamdbda is optional, so lets remove it (run the code again to make sure all is ok):\n\n~~~\n    println(\"\\nUsing Lambdas:\\n\")\n    fruit.forEach  {println(it)}\n~~~\n\n\n##Using Lambdas to Filter Collections\n\nOur last line of code in the main function should read:\n\n~~~\n    fruit.forEach  {println(it)}\n~~~\n\nWe are going to update this line so that we can filter out all items except those that contain *an*.  Make this change:\n\n~~~\n    fruit.filter {it.contains(\"an\")}\n         .forEach {println(it)}\n~~~\n\nRun the code, and only *Banana* and *Orange* should be displayed to the console.\n\n\n##Using Lambdas to Sort Collections\n\nOur last line of code in the main function should read:\n\n~~~\n    fruit.filter {it.contains(\"an\")}\n         .forEach {println(it)}\n~~~\n\nWe are going to update this line so that we can sort the qualifying items.  As our data is already in alphabetic order, we will sort descending.  Make this change:\n\n~~~\n    fruit.filter {it.contains(\"an\")}\n         .sortedByDescending { it }\n         .forEach {println(it)}\n~~~\n\nRun the code, and only *Banana* and *Orange* should be displayed to the console, but this time, they are displayed in descending order with Orange first, then Banana.\n\n\n##Using Lambdas to display in Uppercase\n\nOur last line of code in the main function should read:\n\n~~~\n    fruit.filter {it.contains(\"an\")}\n         .sortedByDescending { it }\n         .forEach {println(it)}\n~~~\n\nWe are going to update this line so that we can display the qualifying items in uppercase.  Make this change:\n\n~~~\n    fruit.filter {it.contains(\"an\")}\n        .sortedByDescending { it }\n        .map {it.toUpperCase()}\n        .forEach {println(it)}\n~~~\n\nRun the code.   Now *ORANGE*, followed by *BANANA* should be displayed.\n\nSave your work and close the project. "
    },
  
    {
    "title": "#Exercises",
    "shortTitle": "Exercises",
    "contentMd" : "#Exercises\n\n\n## Exercise 1: \n\nIf you have time to spare, experiment with the constructs we covered in this lab and/or experiment with this kotlin learning resource:\n\n<https://kotlinlang.org/docs/tutorials/koans.html>\n\n"
    },
  
    {
    "title": "#Solution",
    "shortTitle": "Solution",
    "contentMd" : "#Solution\n\nShould you need it, the solution for the lab is here:\n\n~~~\nfun main(args: Array<String>) {\n\n    val myArray = arrayOf(4, 5, 6, 7)\n    println(myArray.asList())\n    println(myArray[2])\n\n    val myMixedArray = arrayOf(4, 5, 6, 7, \"mixed\", \"types\", \"allowed\")\n    println(myMixedArray.asList())\n    println(myMixedArray)\n\n    val intArray1    = intArrayOf(4, 5, 6, 7)\n    val intArray2    = arrayOf<Int>(4, 5, 6, 7)\n    val charArray    = charArrayOf('a', 'b', 'c', 'd')\n    val booleanArray = booleanArrayOf(true, false, true)\n\n    println(\"IntArray1 : ${intArray1.asList()} and is type ${intArray1.javaClass.typeName}\")\n    println(\"IntArray2 : ${intArray2.asList()} and is type ${intArray2.javaClass.typeName}\")\n    println(\"charArray : ${charArray.asList()} and is type ${charArray.javaClass.typeName}\")\n    println(\"booleanArray : ${booleanArray.asList()} and is type ${booleanArray.javaClass.typeName}\")\n\n    val intArray = Array(6,  {i -> i * 2} )\n    println (\"Array using Constructor: ${intArray.asList()}\")\n\n\n    //MUTABLE LIST\n    val fruit = mutableListOf(\"Banana\", \"Kiwifruit\", \"Mango\", \"Apple\")\n    println(\"Mutable List: ${fruit}\")\n    //add an item\n    fruit.add(\"Pear\")\n    println(\"Mutable List: ${fruit}\")\n    //update an item\n    fruit[1] = \"Orange\"\n    println(\"Mutable List: ${fruit}\")\n    //remove an item\n    fruit.removeAt(2)\n    println(\"Mutable List: ${fruit}\")\n\n\n    //IMMUTABLE LIST\n    val mutableNumbers: MutableList<Int> = mutableListOf(1, 2, 3)\n    val readOnlyView: List<Int> = mutableNumbers\n\n    println(\"Mutable numbers: ${mutableNumbers}\")        // prints \"[1, 2, 3]\"\n    mutableNumbers.add(4)\n\n    println(\"Read only view: ${readOnlyView}\")   // prints \"[1, 2, 3, 4]\"\n\n    //ITERATING\n    for(fruitItem in fruit)\n        println(fruitItem)\n\n    println(\"\\nUsing Lambdas:\\n\")\n    fruit.filter {it.contains(\"an\")}\n        .sortedByDescending { it }\n        .map {it.toUpperCase()}\n        .forEach {println(it)}\n\n\n}\n~~~\n\n"
    }
  
  ]
  }

