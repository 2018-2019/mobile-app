


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Kotlin Lab-01 Intro",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Introduction to Kotlin and the IntelliJ IDEA.</p>",
  "folder" : "book-01-intro-to-kotlin",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "#Objectives",
    "shortTitle": "Kotlin Lab-01 Intro",
    "contentMd" : "#Objectives\n\nIntroduction to Kotlin and the IntelliJ IDEA."
    },
  
    {
    "title": "# HelloWorld",
    "shortTitle": "01",
    "contentMd" : "# HelloWorld\n\n##New Project in IntelliJ\n\nOpen IntelliJ (it is installed on the college computers).\n\nFrom the Welcome to IntelliJ IDE screen, choose Create New Project.\n\nOn the *New Project* screen, choose *Gradle* in the left column (don't select Kotlin or Java). \n\nUnder *Additional Libraries and Frameworks*, check both *Java* and *Kotlin (Java)*.  Click the *Next* button.\n\nEnter the following details and click the *Next* button:\n\n![](img/01.png)\n\n\nCheck the following options are selected and then click the *Next* button:\n\n![](img/02.png)\n\n\nChoose a location for your project and click the *Finish* button:\n\n![](img/03.png)\n\nGradle will start downloading required dependencies.  When this is finished, you should have the following project structure:\n\n![](img/04.png)\n\nNote that all of our Kotlin files will be kept in the kotlin directory above and, likewise, the Java files will be kept in the Java directory. \n\n\n##New Kotlin Class\n\nRight click on the *src/main/kotlin* directory and, when the context menu appears, select *New* followed by *Kotlin Class/File*.\n\nWhen the window appears, enter the class name in the format of *packagename.classname* i.e.:\n\n![](img/05.png)\n\nEnter the following code into this new file:\n\n~~~\nfun main(args: Array<String>){\n    println(\"Hello World\")\n}\n~~~\n\n...and then run it.  You should have the following output:\n\n![](img/06.png)\n\nSave your work."
    },
  
    {
    "title": "# Types Project",
    "shortTitle": "02",
    "contentMd" : "# Types Project\n\nKotlin has two keywords used to declare variables, *val* and *var*:\n\n- *val* creates an immutable declaration. Use this keyword when the value of the declaration won't change once set.  Use this one whenever possible.\n- *var* is used for a mutable declaration i.e. value can change. \n\nIn this project, we will familiarise ourselves with creating variables, kotlin types and type inference \n\n\n##New Project in IntelliJ\n\nIn IntelliJ, create a new project.  When the *New Project* window appears, remember to choose:\n\n- *Gradle* and \n- under *Additional Libraries and Frameworks*, check both *Java* and *Kotlin (Java)*.\n\nUse the following credentials for your new project:\n\n![](img/07.png)\n\nand ensure that the chosen location for your project is ok:\n\n![](img/08.png)\n\nGradle will start downloading required dependencies.\n\n\n##New Kotlin Class\n\nRight click on the *src/main/kotlin* directory and, when the context menu appears, select *New* followed by *Kotlin Class/File*.\n\nWhen the window appears, enter the class name in the format of *packagename.classname* i.e. **com.wit.types.main** and click ok.\n\nEnter the following code into this new file:\n\n~~~\nfun main(args: Array<String>){\n    println(\"Working with Variables and Types\")\n}\n~~~\n\n...and then run it.  You should have the following output:\n\n![](img/09.png)\n\nWe are now ready to start experimenting with variables and types.\n\n\n##Basic Types (no type inference)\n\n**In this section, we would strongly advise typing in the supplied code so you can familiarise yourself with the Kotlin syntax.**\n\nThe following code explicitly defines the type for 6 different immutable variables.  Type this code into your *main* function:\n\n~~~\n    val doubleNumber: Double = 1200.45\n    val floatNumber: Float = 700.78f\n    val longNumber: Long = 98765432\n    val intNumber: Int = 123456\n    val shortNumber: Short = 345\n    val byteNumber: Byte = 127\n~~~\n\nAnd then add the following lines of code:\n\n~~~\n    println(\"doubleNumber value is: \" + doubleNumber + \", and the type is: \" + doubleNumber.javaClass)\n    println(\"floatNumber value is:  \" + floatNumber + \", and the type is: \" + floatNumber.javaClass)\n    println(\"longNumber value is:   \" + longNumber + \", and the type is: \" + longNumber.javaClass)\n    println(\"intNumber value is:    \" + intNumber + \", and the type is: \" + intNumber.javaClass)\n    println(\"shortNumber value is:  \" + shortNumber + \", and the type is: \" + shortNumber.javaClass)\n    println(\"byteNumber value is:   \" + byteNumber + \", and the type is: \" + byteNumber.javaClass)\n~~~\n\nWhen you run the code, you can clearly see that the kotlin type matches with the Java primitive type, which matches with the explicitly declared type:\n\n![](img/10.png)\n\n\n##Basic Types (with type inference)\n\nNow remove the type declaration from the above code (we will now infer the type from the value supplied at variable declaration time) i.e.:\n\n~~~\n    val doubleNumber = 1200.45\n    val floatNumber = 700.78f\n    val longNumber = 98765432\n    val intNumber = 123456\n    val shortNumber = 345\n    val byteNumber = 127\n~~~\n\nRun the code again and note the new inferred types...can you now see what the purpose of the **f** is in the value for floatNumber:\n\n![](img/11.png)\n\nUpdate the definition for the *longNumber* variable to be:\n\n~~~\n    val longNumber = 98765432L\n~~~\n\nAnd run the code again.  Verify that the inferred type is now *long*.\n\n\n##Values with Underscores\n\nYou can use underscores in numbers to make the values in your code more readable.  The underscores do not affect the value at all.  Try this code in your main function:\n\n~~~\n    println(\"\\nUsing underscores to make values more readable:\")\n    val oneMillion = 1_000_000\n    val threeThousand = 3_000\n    val creditCardNumber = 1234_4321_5678_8765\n\n    println(\"\\t\" + oneMillion + \" - the type is: \" + oneMillion.javaClass)\n    println(\"\\t\" + threeThousand + \" - the type is: \" + threeThousand.javaClass)\n    println(\"\\t\" + creditCardNumber + \" - the type is: \" + creditCardNumber.javaClass)\n~~~\n\nWhen you run it, note how the value printed excludes the underscores.  Also note the inferred type for each variable.  Why do you think long was selected instead of int for the variable *creditCardNumber*.\n\nSave your work...we will continue working on this project in the next step!\n\n"
    },
  
    {
    "title": "# Types Project (contd)",
    "shortTitle": "03",
    "contentMd" : "# Types Project (contd)\n\n\n##Numbers:  Implicit Conversions\n\nIn Kotlin, there are no implicit widening conversions for numbers i.e. smaller types (e.g. Byte) are not subtypes of bigger ones (e.g. Int)\n\nIn the main function of the types project, try this code out now:\n\n~~~\n    val byteNum: Byte = 10    //static type check: OK\n    val intNum: Int = byteNum //syntax error\n~~~\n\n\n##Numbers:  Explicit Conversions\n\nIn Kotlin, you need to use *explicit* concversions to widen numbers!  Eliminitate the above syntax error by making the following code change:\n\n~~~\n    val byteNum: Byte = 10              //static type check: OK\n    val intNum: Int = byteNum.toInt()   //explicit conversion: OK\n~~~\n\nEach number type supports explicit number conversions.  Let's try another few conversions:\n\n~~~\n    val floatNum: Float = byteNum.toFloat()\n    val doubleNum: Double = intNum.toDouble()\n~~~\n\nFor each of the variables above, print out the value and also the type.  Ensure that the types are what you were expecting. \n\n\n##Character types\n\nThe character type in Kotlin is the *Char*.  Like numbers, you can use type inference when defining characters.  Try this code in your main function:\n~~~\n    //characters in kotlin\n    val aChar = 'a'\t\t\t//type inference\n    val bChar: Char = 'b'   //explicitly defining the type\n~~~\n\nNow try printing out the value and the type of each of these variables:\n~~~\n    println(\"aChar: \" + aChar + \" - the type is: \" + aChar.javaClass)\n    println(\"bChar: \" + bChar + \" - the type is: \" + bChar.javaClass)\n~~~\n\nWhen you run your main function, you should now have output similar to this at the end of the print stream:\n\n~~~\naChar: a - the type is: char\nbChar: b - the type is: char\n~~~\n\nYou are probably noticing that the print output to the console is getting larger and larger as we progress through the lab...we will show you in a few steps how to write functions in Kotlin and we will farm out some of this code into these functions. \n\n\n##Boolean types\n\nThe boolean type in Kotlin is *Boolean*.  Once again, you can use type inference when declaring these.  Try this code in your main function:\n~~~\n    //booleans in kotlin\n    val aFlag = true\n    val bFlag: Boolean = false\n~~~\n\nNow try printing out the value and the type of each of these variables:\n\n~~~\n    println(\"aFlag: \" + aFlag + \" - the type is: \" + aFlag.javaClass)\n    println(\"bFlag: \" + bFlag + \" - the type is: \" + bFlag.javaClass)\n~~~\n\nWhen you run your main function, you should now have output similar to this at the end of the print stream:\n\n~~~\naFlag: true - the type is: boolean\nbFlag: false - the type is: boolean\n~~~\n\nSave your work and keep the project open.\n"
    },
  
    {
    "title": "# val vs var",
    "shortTitle": "04",
    "contentMd" : "# val vs var\n\nIn the previous steps, we used *val* to create our variables.  In this step, we will look at *var* and uncover the difference between the two.\n\nWe will continue working in the *types* project from the previous steps.\n\n\n##val - deferred initialisation\n\nSo far, we have only used *val* to declare our variables.  For example:\n\n~~~\n    //numbers in kotlin\n    val oneMillion = 1_000_000\n    val byteNum: Byte = 10              \n\n    //characters in kotlin\n    val aChar = 'a'\t\t\t//type inference\n    val bChar: Char = 'b'   //explicitly defining the type\n\n    //booleans in kotlin\n    val aFlag = true\n    val bFlag: Boolean = false\n~~~\n\nThese variables are immutable i.e. once they are assigned a value, the value cannot be changed (similar to *final* variables in java).\n  \nIn all the examples above, we assigned a value immediately.  Lets update our code to defer the assignment of a value until later in the code.  To do this, change the following character variable declaration in your code from:\n\n~~~\n    val bChar: Char = 'b'   //explicitly defining the type and setting the value\n~~~\n\nto be:\n\n~~~\n    val bChar: Char      //explicitly defining the type - no value set\n~~~\n\nWe have generated a syntax error:\n\n![](img/12.png)\n\nFix this error by inserting this initialisation between the two print statements:\n\n~~~\n    println(\"aChar: \" + aChar + \" - the type is: \" + aChar.javaClass)\n    bChar = 'b'\n    println(\"bChar: \" + bChar + \" - the type is: \" + bChar.javaClass)\n~~~\n\nOur code now compiles, but did you notice that IntelliJ is still not happy...the variable *bChar* is still underlined...it's not a syntax error this time, but a helpful message.  Hover your mouse pointer over the variable and you should see the following message appear:\n\n![](img/13.png)\n\nClick on the *more* link to read the full message.  IntelliJ provides a lot of helpful messages like this and an even easier way to accept their suggestions.  Click on the light bulb and the click the option *Join declaration and assignment*:\n\n![](img/14.png)\n\nThe code should be refactored for you and the warning message should be gone.  \n\nThe above demonstrated that you can defer the initialisation of a *val* variable until later, but it may not be the best style depending on the situation.  An example where it is good style...if you were reading in the value from the user, you wouldn't get this warning message displayed.\n\n\n##val - cannot change value\n\nStaying with the same variable we were updating above (bChar), add this line of code just before printing out the value:\n\n~~~\n   bChar = 'B'\n~~~\n\nYour code should now look like this, inclusive of the syntax error:\n\n![](img/15.png)\n\n*bChar* is an immutable variable and cannot be reassigned.  \nDelete this line of code we just added.\n\n\n##var - mutable variables\n\nAt the end of the main function, declare a mutable variable:\n\n~~~\n    //mutable variable\n    var number = 5   //Int type is inferred\n~~~\n\nAs the value is allowed to change in *var* variables, you can do mathematical operations:\n\n~~~    \n    number ++;       //mathematical operations are allowed\n    println(\"number: \" + number)\n~~~\n\nand reassignment:\n\n~~~\n    number = 3;       //Allowed to reassign a var too\n    println(\"number: \" + number)\n~~~\n\nSave your work and keep the project open.\n"
    },
  
    {
    "title": "# functions (without parameters)",
    "shortTitle": "05",
    "contentMd" : "# functions (without parameters)\n\nWe will continue working in the *types* project from the previous steps.\n\nHaving worked though this lab, your main function will be quite large e.g. you will have something similar to this:\n\n~~~\nfun main(args: Array<String>) {\n \n    println(\"Working with Variables and Types\")\n\n    //Variables in kotlin and their types\n\n    val doubleNumber = 1200.45\n    val floatNumber = 700.78f\n    val longNumber = 98765432L\n    val intNumber = 123456\n    val shortNumber = 345\n    val byteNumber = 127\n\n    println(\"doubleNumber value is: \" + doubleNumber + \", and the type is: \" + doubleNumber.javaClass)\n    println(\"floatNumber value is:  \" + floatNumber + \", and the type is: \" + floatNumber.javaClass)\n    println(\"longNumber value is:   \" + longNumber + \", and the type is: \" + longNumber.javaClass)\n    println(\"intNumber value is:    \" + intNumber + \", and the type is: \" + intNumber.javaClass)\n    println(\"shortNumber value is:  \" + shortNumber + \", and the type is: \" + shortNumber.javaClass)\n    println(\"byteNumber value is:   \" + byteNumber + \", and the type is: \" + byteNumber.javaClass)\n\n\n    //underscores make number values more readable in code\n\n    println(\"\\nUsing underscores to make values more readable:\")\n    val oneMillion = 1_000_000\n    val threeThousand = 3_000\n    val creditCardNumber = 1234_4321_5678_8765\n\n    println(\"\\t\" + oneMillion + \" - the type is: \" + oneMillion.javaClass)\n    println(\"\\t\" + threeThousand + \" - the type is: \" + threeThousand.javaClass)\n    println(\"\\t\" + creditCardNumber + \" - the type is: \" + creditCardNumber.javaClass)\n\n\n    //explicit conversion of value\n\n    val byteNum: Byte = 10              //static type check: OK\n    val intNum: Int = byteNum.toInt()   //explicit conversion: OK\n    val floatNum: Float = byteNum.toFloat()\n    val doubleNum: Double = intNum.toDouble()\n\n\n    //characters in kotlin\n    val aChar = 'a'\t\t\t//type inference\n    val bChar: Char = 'b'   //explicitly defining the type\n\n    println(\"aChar: \" + aChar + \" - the type is: \" + aChar.javaClass)\n    println(\"bChar: \" + bChar + \" - the type is: \" + bChar.javaClass)\n\n\n    //booleans in kotlin\n    val aFlag = true\n    val bFlag: Boolean = false\n\n    println(\"aFlag: \" + aFlag + \" - the type is: \" + aFlag.javaClass)\n    println(\"bFlag: \" + bFlag + \" - the type is: \" + bFlag.javaClass)\n\n\n    //mutable variables\n    var number = 5   //Int type is inferred\n    number ++;       //mathematical operations are allowed\n    println(\"number: \" + number)\n    number = 3;       //Allowed to reassign a var too\n    println(\"number: \" + number)\n\n}\n~~~\n\nIn this and the following step, we are going to create new functions in main.kt, some of which take parameters and some of which don't.  \n\n##factory reset!!!\n\nDelete all the statements in your *fun main*, but leave the function declaration i.e. :\n\n~~~\nfun main(args: Array<String>) {\n}\n~~~\n\n\n##Your First function without parameters\n\nFirst, we will add a new function called *typeInference* that doesn't take any parameters...type this code:\n\n~~~\nfun typeInference() {\n    \n}\n~~~\n\nThen cut and paste the following code into this function:\n\n~~~\n    println (\"\\n==========================================================\")\n    println (\"============  Using Type Inference in Kotlin =============\")\n    println (\"==========================================================\")\n\n    val doubleNumber = 1200.45\n    val floatNumber = 700.78f\n    val longNumber = 98765432L\n    val intNumber = 123456\n    val shortNumber = 345\n    val byteNumber = 127\n\n    println(\"doubleNumber value is: \" + doubleNumber + \", and the type is: \" + doubleNumber.javaClass)\n    println(\"floatNumber value is:  \" + floatNumber + \", and the type is: \" + floatNumber.javaClass)\n    println(\"longNumber value is:   \" + longNumber + \", and the type is: \" + longNumber.javaClass)\n    println(\"intNumber value is:    \" + intNumber + \", and the type is: \" + intNumber.javaClass)\n    println(\"shortNumber value is:  \" + shortNumber + \", and the type is: \" + shortNumber.javaClass)\n    println(\"byteNumber value is:   \" + byteNumber + \", and the type is: \" + byteNumber.javaClass)\n~~~\n\nNow let's call this new function from the *main* function:\n\n~~~\nfun main(args: Array<String>) {\n    typeInference()\n}\n~~~\n\nRun the code...you should get output similar to this:\n\n~~~\n==========================================================\n============  Using Type Inference in Kotlin =============\n==========================================================\ndoubleNumber value is: 1200.45, and the type is: double\nfloatNumber value is:  700.78, and the type is: float\nlongNumber value is:   98765432, and the type is: long\nintNumber value is:    123456, and the type is: int\nshortNumber value is:  345, and the type is: int\nbyteNumber value is:   127, and the type is: int\n~~~\n\n\n##Another function that doesn't take parameters\n\nAdd another function called *usingUnderscores* that doesn't take any parameters.\n\nThen cut and paste the following code into this function:\n\n~~~\n    println (\"\\n==========================================================\")\n    println (\"=========  Using underscores in numeric values ===========\")\n    println (\"==========================================================\")\n\n    //underscores make number values more readable in code\n\n    println(\"\\nUsing underscores to make values more readable:\")\n    val oneMillion = 1_000_000\n    val threeThousand = 3_000\n    val creditCardNumber = 1234_4321_5678_8765\n\n    println(\"\\t\" + oneMillion + \" - the type is: \" + oneMillion.javaClass)\n    println(\"\\t\" + threeThousand + \" - the type is: \" + threeThousand.javaClass)\n    println(\"\\t\" + creditCardNumber + \" - the type is: \" + creditCardNumber.javaClass)\n    println()\n~~~\n\nAnd call the new function from the *main* function.\n\nRun the code...you should get output similar to this:\n\n~~~\n==========================================================\n============  Using Type Inference in Kotlin =============\n==========================================================\ndoubleNumber value is: 1200.45, and the type is: double\nfloatNumber value is:  700.78, and the type is: float\nlongNumber value is:   98765432, and the type is: long\nintNumber value is:    123456, and the type is: int\nshortNumber value is:  345, and the type is: int\nbyteNumber value is:   127, and the type is: int\n\n\n==========================================================\n=========  Using underscores in numeric values ===========\n==========================================================\n\nUsing underscores to make values more readable:\n\t1000000 - the type is: int\n\t3000 - the type is: int\n\t1234432156788765 - the type is: long\n~~~\n\n\n##And another function that doesn't take parameters\n\nAdd a third function called *booleansAndCharacters* that doesn't take any parameters.\n\nThen cut and paste the following code into this function:\n\n~~~\n    println (\"\\n==========================================================\")\n    println (\"================  Booleans and Characters ================\")\n    println (\"==========================================================\")\n\n    //characters in kotlin\n    val aChar = 'a'            //type inference\n    val bChar: Char = 'b'   //explicitly defining the type\n    println(\"aChar: \" + aChar + \" - the type is: \" + aChar.javaClass)\n    println(\"bChar: \" + bChar + \" - the type is: \" + bChar.javaClass)\n\n\n    //booleans in kotlin\n    val aFlag = true\n    val bFlag: Boolean = false\n    println(\"aFlag: \" + aFlag + \" - the type is: \" + aFlag.javaClass)\n    println(\"bFlag: \" + bFlag + \" - the type is: \" + bFlag.javaClass)\n\n    println()\n~~~\n\nAnd call the new function from the *main* function.\n\nRun the code...you should get output similar to this:\n\n~~~\n==========================================================\n============  Using Type Inference in Kotlin =============\n==========================================================\ndoubleNumber value is: 1200.45, and the type is: double\nfloatNumber value is:  700.78, and the type is: float\nlongNumber value is:   98765432, and the type is: long\nintNumber value is:    123456, and the type is: int\nshortNumber value is:  345, and the type is: int\nbyteNumber value is:   127, and the type is: int\n\n\n==========================================================\n=========  Using underscores in numeric values ===========\n==========================================================\n\nUsing underscores to make values more readable:\n\t1000000 - the type is: int\n\t3000 - the type is: int\n\t1234432156788765 - the type is: long\n\n\n==========================================================\n================  Booleans and Characters ================\n==========================================================\naChar: a - the type is: char\nbChar: b - the type is: char\naFlag: true - the type is: boolean\nbFlag: false - the type is: boolean\n~~~\n\nSave your code.  In the next step, we will look at adding functions that take parameters.\n\n\n\n\n"
    },
  
    {
    "title": "# functions (with parameters)",
    "shortTitle": "06",
    "contentMd" : "# functions (with parameters)\n\nWe will continue working in the *types* project from the previous steps.\n\nWe will now work on functions that take parameters. \n\n##Your First function WITH parameters\n\nAdd a new function called *explicitConversions* that takes one parameter of type Byte:\n\n~~~\nfun explicitConversions(inputByte : Byte){\n\n}\n~~~\n\nTry removing *Byte* from the parameter list above...what happened?  What's the generated error in IntelliJ?  Does it make sense to you why you must provide a type here?  Put back in the declared type. \n\nNow cut and paste the following code into this function:\n\n~~~\n    println (\"\\n==========================================================\")\n    println (\"=================  Explicit Conversions ==================\")\n    println (\"==========================================================\")\n\n    val byteNum: Byte = inputByte       //static type check: OK\n    val intNum: Int = byteNum.toInt()   //explicit conversion: OK\n    val floatNum: Float = byteNum.toFloat()\n    val doubleNum: Double = intNum.toDouble()\n\n    println(\"byteNum: \"   + byteNum)\n    println(\"intNum: \"    + intNum)\n    println(\"floatNum: \"  + floatNum)\n    println(\"doubleNum: \" + doubleNum)\n\n    println()\n~~~\n\nRead the above code...can you see where the parameter is used in the code? \n\nAnd call the new function from the *main* function, passing 25 as the actual parameter.\n\nRun the code...along with the output from the previous function calls, you should have output similar to this:\n\n~~~\n==========================================================\n=================  Explicit Conversions ==================\n==========================================================\nbyteNum: 25\nintNum: 25\nfloatNum: 25.0\ndoubleNum: 25.0\n~~~\n\n\n##A function WITH two parameters\n\nAdd a new function called *mutableVariables* that takes two parameters, both of type Int:\n\n~~~\nfun mutableVariables (input: Int, updatedNumber: Int){\n\n}\n~~~\n\nNow cut and paste the following code into this function:\n\n~~~\n    println (\"\\n==========================================================\")\n    println (\"===========  Working with Mutable Variables =============\")\n    println (\"==========================================================\")\n\n    //mutable variables\n    var number = input   //Int type is inferred\n\n    number++;       //mathematical operations are allowed\n    println(\"number: \" + number)\n\n    number = updatedNumber;       //Allowed to reassign a var too\n    println(\"number: \" + number)\n\n    println()\n~~~\n\nRead the above code...can you see where the parameters are used in the code? \n\nAnd call the new function from the *main* function, passing 10 and 20 as the actual parameter value.\n\nRun the code...along with the output from the previous function calls, you should have output similar to this:\n\n~~~\n==========================================================\n===========  Working with Mutable Variables =============\n==========================================================\nnumber: 11\nnumber: 20\n~~~\n\nSave your code.\n\n"
    },
  
    {
    "title": "#Exercises",
    "shortTitle": "Exercises",
    "contentMd" : "#Exercises\n\n##Lab is Complete!\n\nYou are now finished your introduction to Kotlin.  \n\nIf you have time to spare, try adding more functions and experiment with the constructs we covered in this lab and/or experiment with this kotlin learning resource:\n\n<https://kotlinlang.org/docs/tutorials/koans.html>\n\n\n"
    }
  
  ]
  }

