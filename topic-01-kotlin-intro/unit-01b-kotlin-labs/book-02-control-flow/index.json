


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Kotlin Lab-02 Control Flow",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Introduction to Control Flow in Kotlin and also Strings and Null Safety.</p>",
  "folder" : "book-02-control-flow",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "#Objectives",
    "shortTitle": "Kotlin Lab-02 Control Flow",
    "contentMd" : "#Objectives\n\nIntroduction to Control Flow in Kotlin and also Strings and Null Safety. "
    },
  
    {
    "title": "# if (statement and expression)",
    "shortTitle": "01",
    "contentMd" : "# if (statement and expression)\n\nIn this part of the lab, we will work on the syntax for flow of control in our kotlin programs, focusing on the *if* as a statement and also as an expression.\n\n##Run IntelliJ as an Administrator\n\nOn the college computers, don't run IntelliJ as normal.  Instead, run it as Adminisrator by right clicking on the Icon and selecting the option *Run as Administrator*.\n\n\n##New Project in IntelliJ\n\nIn IntelliJ, create a new project.  When the *New Project* window appears, remember to choose:\n\n- *Gradle* and \n- under *Additional Libraries and Frameworks*, check both *Java* and *Kotlin (Java)*.\n\nUse the following credentials for your new project:\n\n![](img/01.png)\n\nand ensure that the chosen location for your project is ok:\n\n![](img/02.png)\n\nGradle will start downloading required dependencies.\n\n\n##New Kotlin Class\n\nRight click on the *src/main/kotlin* directory and, when the context menu appears, select *New* followed by *Kotlin Class/File*.\n\nWhen the window appears, enter the class name in the format of *packagename.classname* i.e. **ie.wit.controlflow.main** and click ok.\n\n\n##if as a statement\n\nEnter the following code into this new file:\n\n~~~\nfun main(args: Array<String>) {\n    maxOf(4, 6)\n}\n\nfun maxOf(a: Int, b: Int) {\n    val max: Int\n\n    //traditional way to write if (as a statement)\n    if (a > b) {\n        max = a\n        print(\"a is greater than b.  The max number is \" + max)\n    } else {\n        max = b\n        print(\"b is greater than a.  The max number is \" + max)\n    }\n}\n~~~\n\nRun the code.  You should have output similar to this:\n\n> *b is greater than a.  The max number is 6*\n\nThis is the traditional form of if-statement that we are used to in Java.\n\n\n##Method with return type\n\nWe are going to rewrite the above code so that we don't store the maximum value in the local variable *max*...instead we will return the max value to the *main* method and print it out from there.\n\nRefactor your code so that it now looks like this:\n\n~~~\nfun main(args: Array<String>) {\n    println(\"The max number is: \" + maxOf(4, 6));\n}\n\nfun maxOf(a: Int, b: Int) : Int {\n\n    //traditional way to write if (as a statement)\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}\n~~~\n\nNote in the code above that we explicitly define a return type for a method by including a colon followed by a type i.e.  **: Int**\n\nWhen you run this code, you should have something like this printed to the console:\n\n> *The max number is: 6*\n\n\n##if as an expression\n\nIn Kotlin, the **if** is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary if works fine in this role.\n\nAs the **if** is an expression in Kotlin, we can rewrite our **maxOf** method like so:\n\n~~~\n//if as an expression\nfun maxOf(a: Int, b: Int) =  if (a > b) a else b\n~~~\n\nRun this code and you should see there is no change in the output.  \n\n\n##if as an expression (with code blocks)\n\nWhen we first started this step, we printed out whether *a* was greater than *b*. We are going to put that code back in now into our *if* (as an expression).\n\nRefactor your *maxOf* method so that your *if* expression has code blocks:\n\n~~~\n//if as an expression\nfun maxOf(a: Int, b: Int) =\n    if (a > b) {\n        print(\"a is greater than b.  \")\n        a\n    }else {\n        print(\"b is greater than a.  \")\n        b\n    }\n~~~\n\nWhen you run the code, you should now have the following output printed to the console:\n\n> *b is greater than a.  The max number is: 6*\n\n\n##if as an expression (else is mandatory)\n\nTry remove the else code block from the *maxOf* method.  The following error should be generated:\n\n![](img/03.png)\n\nWhen an *if* is used as an expression, the *else* portion is mandatory.\n\nSave your work, but keep the project open.\n\n"
    },
  
    {
    "title": "# when (switch in Java)",
    "shortTitle": "02",
    "contentMd" : "# when (switch in Java)\n\nContinuing with kotlin flow of control, we will now look at the *when* construct.\n\nCurrently your main class should look like this:\n\n~~~\nfun main(args: Array<String>) {\n    println(\"The max number is: \" + maxOf(4, 6));\n}\n\n//if as an expression\nfun maxOf(a: Int, b: Int) =\n    if (a > b) {\n        print(\"a is greater than b.  \")\n        a\n    }else {\n        print(\"b is greater than a.  \")\n        b\n    }\n~~~\n\nWe will now add *when* functionality to it.\n\n\n## when \n\nThe *when* construct is equivalent to *switch* in Java, but it is more powerful.  Type in the following code into your *main* class:\n\n~~~\n//when construct\nfun printValue(value : Int){\n    when(value){\n        1 -> println (\"The value is One\")\n        2 -> println (\"The value is Two\")\n        in 3..5 -> println (\"The value is between Three and Five\")\n        else -> {\n            println (\"The value is: \" + value)\n        }\n    }\n~~~\n\nIn particular, note the *range* operator e.g. 3..5\nAlso note that there is an *else* portion included.  We should include our curly brackets with the else (a warning is generated otherwise).\n\nRun this code by adding the following function call as the last statement in your main function:\n\n~~~\n    printValue(3)\n~~~\n\nThe following output should be printed to your console:\n\n> *b is greater than a.  The max number is: 6*\n\n> *The value is between Three and Five*\n\n\n##when (combining conditions with a comma)\n\nWe can combine branch conditions with a comma (update your code with the 6,7,8 case):\n\n~~~\n//when construct\nfun printValue(value : Int){\n    when(value) {\n        1 -> println(\"The value is One\")\n        2 -> println(\"The value is Two\")\n        in 3..5 -> println(\"The value is between Three and Five\")\n        6, 7, 8 -> println(\"The value is either Six, Seven or Eight\")\n        else -> {\n            println(\"The value is: \" + value)\n        }\n    }\n}\n~~~\n\nand change your method call in *main* to be *printValue (7)* so that it invokes your new code.  The following should be printed to the console:\n\n> *b is greater than a.  The max number is: 6*\n\n> *The value is either Six, Seven or Eight*\n\n\n##when (!in and in)\n\nWe can use *!in* as well as *in*.  \n\nWrite the following new function to use these capabilities and invoke it from *main* using *printRange(30)*:\n\n~~~\nfun printRange(value: Int){\n    when(value){\n        in 1..10 -> println (\"Between 1..10\");\n        !in 10..20 -> println (\"Outside 10..20\")\n    }\n}\n~~~\n\nWhen you run it, you should have the following output:\n\n> *b is greater than a.  The max number is: 6*\n\n> *The value is either Six, Seven or Eight*\n\n> *Outside 10..20*\n\n\n## when (arbitrary expressions as conditions)\n\nWe can use arbitrary expressions as branch conditions.  \n\nWrite the following new function to use this capability and invoke it from *main* using *printExpressionResult(12, \"12\")*:\n\n~~~\nfun printExpressionResult(numberValue: Int, stringValue: String){\n    when (numberValue){\n        parseInt(stringValue) -> println(\"stringValue holds the same number as numberValue\")\n        else -> {\n            println(\"stringValue is not the same number as numberValue\")\n        }\n    }\n}\n~~~\n\nWhen you run it, you should have the following output:\n\n> *b is greater than a.  The max number is: 6*\n\n> *The value is either Six, Seven or Eight*\n\n> *Outside 10..20*\n\n> *stringValue holds the same number as numberValue*\n\n\n##when (!is and is)\n\nWe can use *!is* as well as *is*.  \n\nWrite the following new function to use these capabilities and invoke it from *main* using *printInferredType()*:\n\n~~~\nfun printInferredType(){\n    val number = 3;\n    when(number){\n        is Int -> println (\"My inferred type is Int\")\n    }\n}\n~~~\n\nWhen you run it, you should have the following output:\n\n> *b is greater than a.  The max number is: 6*\n\n> *The value is either Six, Seven or Eight*\n\n> *Outside 10..20*\n\n> *stringValue holds the same number as numberValue*\n\n> *My inferred type is Int*\n\n\n## when (no argument) \n\n*when* can also be used as a replacement for an *if-else* chain. \n\nIf no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true.\n    \nWrite the following new function and invoke it from *main* and invoke it using *printAnimal(\"Guinea pig\")*:\n\n~~~\nfun printAnimal(aString: String){\n    when {\n        aString.equals(\"Dog\") -> println(\"A dog\")\n        aString.equals(\"Cat\") -> println(\"A cat\")\n        aString.contains(\"pig\") -> println(\"A pig of some sort\")\n        aString.length == 0 -> println(\"Empty String..no Animal\")\n        else -> {\n            println(\"No identifiable animal\")\n        }\n    }\n}\n~~~\n\nWhen you run it, you should have the following output:\n\n> *b is greater than a.  The max number is: 6*\n\n> *The value is either Six, Seven or Eight*\n\n> *Outside 10..20*\n\n> *stringValue holds the same number as numberValue*\n\n> *My inferred type is Int*\n\n> *A pig of some sort*\n\n\nChange the invoking of the method to ensure that another branch is invoked when you run the code e.g. **printAnimal(\"\")**, **printAnimal(\"elephant\")**\n\n\nSave your work, but keep the project open.\n\n"
    },
  
    {
    "title": "# when (as an expression)",
    "shortTitle": "03",
    "contentMd" : "# when (as an expression)\n\nContinuing with kotlin flow of control, we will now look at the *when* construct as an expression.\n\n\n##when (as an expression)\n\nJust like we did with the *if*, we can use *when* as an expression.  \n\nFirst enter the following function to your code:\n\n~~~\nfun describe(obj: Any): String {\n\n    var result : String = when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n    }\n\n    return result\n}\n~~~\n\nAnd add the following function calls to your *main* function:\n\n~~~\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n~~~\n\nThe last few lines of your console output should now be:\n\n> *One*\n\n> *A Greeting*\n\n> *Long Var*\n\n> *Not a String*\n\n> *Unknown*\n\n\nNow let's enhance this new function by eliminating the *result* variable (try use IntelliJs Alt+Enter to make this change) :\n\n~~~\nfun describe(obj: Any): String {\n\n    return when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n    }\n}\n~~~\n\nRun your code again...you should have the same output as above.\n\nNow let's reduce our code even further:\n\n~~~\nfun describe(obj: Any): String = when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n    }\n~~~\n\nRun your code again...you should have the same output as above.\n\n\n##Refactoring some other functions to have a return type\n\nWe will now use IntelliJ's yellow lightbulb to refactor some of our functions so that our *when* constructs are expressions, like the *describe* function above.\n\nCurrently the *printAnimal* method looks like this:\n\n~~~\nfun printAnimal(aString: String){\n    when {\n        aString.equals(\"Dog\") -> println(\"A dog\")\n        aString.equals(\"Cat\") -> println(\"A cat\")\n        aString.contains(\"pig\") -> println(\"A pig of some sort\")\n        aString.length == 0 -> println(\"Empty String..no Animal\")\n        else -> {\n            println(\"No identifiable animal\")\n        }\n    }\n}\n~~~\n\nHover your mouse over the function *printAnimal*.  When the yellow lightbulb appears, click on it.  Select the option *Convert to expression body*.  Your code should now be:\n\n~~~\nfun printAnimal(aString: String) = when {\n    aString.equals(\"Dog\") -> println(\"A dog\")\n    aString.equals(\"Cat\") -> println(\"A cat\")\n    aString.contains(\"pig\") -> println(\"A pig of some sort\")\n    aString.length == 0 -> println(\"Empty String..no Animal\")\n    else -> {\n        println(\"No identifiable animal\")\n    }\n}\n~~~    \n\nNow make the following changes so that the method isn't printing to the console, it is returning the String instead:\n\n~~~\nfun printAnimal(aString: String) = when {\n    aString.equals(\"Dog\") -> \"A dog\"\n    aString.equals(\"Cat\") -> \"A cat\"\n    aString.contains(\"pig\") -> \"A pig of some sort\"\n    aString.length == 0 -> \"Empty String..no Animal\"\n    else -> \"No identifiable animal\"\n}\n~~~\n\nLastly, you will need to update the call to this method from *printAnimal(\"elephant\")* to *println(printAnimal(\"elephant\"))*\n\nRun your code to make sure all is working as expected with this function.  \n\nThen repeat this process for the following functions:\n\n- printExpressionResult\n- printValue\n\nYou are probably noticing that this makes your code much cleaner looking.\n\nSave your work, but keep the project open.\n\n\n##Solution - so far\n\nIf you need it, the solution to this step is here:\n\n~~~\nimport java.lang.Integer.parseInt\n\nfun main(args: Array<String>) {\n    println(\"The max number is: \" + maxOf(4, 6))\n    println(printValue(7))\n    printRange(30)\n    println(printExpressionResult(12, \"12\"))\n    printInferredType()\n    println(printAnimal(\"elephant\"))\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n}\n\n//if as an expression\nfun maxOf(a: Int, b: Int) =\n    if (a > b) {\n        print(\"a is greater than b.  \")\n        a\n    }else {\n        print(\"b is greater than a.  \")\n        b\n    }\n\n//when construct\nfun printValue(value : Int) = when(value) {\n    1 -> \"The value is One\"\n    2 -> \"The value is Two\"\n    in 3..5 -> \"The value is between Three and Five\"\n    6, 7, 8 -> \"The value is either Six, Seven or Eight\"\n    else -> \"The value is: \" + value\n}\n\nfun printRange(value: Int){\n    when(value){\n        in 1..10 -> println (\"Between 1..10\")\n        !in 10..20 -> println (\"Outside 10..20\")\n    }\n}\n\nfun printExpressionResult(numberValue: Int, stringValue: String) = when (numberValue){\n    parseInt(stringValue) ->  \"stringValue holds the same number as numberValue\"\n    else -> \"stringValue is not the same number as numberValue\"\n}\n\nfun printInferredType(){\n    val number = 3\n    when(number){\n        is Int -> println (\"My inferred type is Int\")\n    }\n}\n\nfun printAnimal(aString: String) = when {\n    aString.equals(\"Dog\") -> \"A dog\"\n    aString.equals(\"Cat\") -> \"A cat\"\n    aString.contains(\"pig\") -> \"A pig of some sort\"\n    aString.length == 0 -> \"Empty String..no Animal\"\n    else -> \"No identifiable animal\"\n}\n\nfun describe(obj: Any): String = when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n}\n~~~"
    },
  
    {
    "title": "# for",
    "shortTitle": "04",
    "contentMd" : "# for\n\nIn our main class, we will add a few more methods to study the *for* loop syntax.  Note that we are using a *List* in the code examples below...we will cover this in detail in lab03.\n\n\n##for-each loop\n\nAdd the following method to your main class:\n\n~~~\nfun forEachStandard(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items){\n        println(\"Item is: \" + item)\n    }\n}\n~~~\n\nAnd call it by including this statement as the last statement in the *main* function:\n\n~~~\n    forEachStandard()\n~~~\n\nWhen run, the last few lines of the console output should now be:\n\n> *Item is: apple*\n\n> *Item is: banana*\n\n> *Item is: kiwi*\n\n\n##for-each with indices\n\nAdd the following method to your main class:\n\n~~~\nfun forEachIndices(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (index in items.indices){\n        println(\"Item at \" + index + \" is: \" + items[index])\n    }\n}\n~~~\n\nAnd call it by including this statement as the last statement in the *main* function:\n\n~~~\n   forEachIndices()\n~~~\n\nWhen run, the last few lines of the console output should now be:\n\n\n> *Item at 0 is: apple*\n\n> *Item at 1 is: banana*\n\n> *Item at 2 is: kiwi*\n\n\n##for-each withIndex library function\n\nThis is another way of accessing the indices like above.\n\nAdd the following method to your main class:\n\n~~~\nfun forEachWithIndex(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for ((index, value) in items.withIndex()){\n        println(\"The item at \" + index + \" is: \" + value)\n    }\n}\n~~~\n\nAnd call it by including this statement as the last statement in the *main* function:\n\n~~~\n    forEachWithIndex()\n~~~\n\nWhen run, the last few lines of the console output should now be:\n\n> *The item at 0 is: apple*\n\n> *The item at 1 is: banana*\n\n> *The item at 2 is: kiwi*\n\n\nSave your work and keep the project open.\n\n\n##Solution - so far\n\nIf you need it, the completed code so far is here:\n\n~~~\nimport java.lang.Integer.parseInt\n\nfun main(args: Array<String>) {\n    println(\"The max number is: \" + maxOf(4, 6))\n    println(printValue(7))\n    printRange(30)\n    println(printExpressionResult(12, \"12\"))\n    printInferredType()\n    println(printAnimal(\"elephant\"))\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n\n    //for loop\n    forEachStandard()\n    forEachIndices()\n    forEachWithIndex()\n}\n\n//if as an expression\nfun maxOf(a: Int, b: Int) =\n    if (a > b) {\n        print(\"a is greater than b.  \")\n        a\n    }else {\n        print(\"b is greater than a.  \")\n        b\n    }\n\n//when construct\nfun printValue(value : Int) = when(value) {\n    1 -> \"The value is One\"\n    2 -> \"The value is Two\"\n    in 3..5 -> \"The value is between Three and Five\"\n    6, 7, 8 -> \"The value is either Six, Seven or Eight\"\n    else -> \"The value is: \" + value\n}\n\nfun printRange(value: Int){\n    when(value){\n        in 1..10 -> println (\"Between 1..10\")\n        !in 10..20 -> println (\"Outside 10..20\")\n    }\n}\n\nfun printExpressionResult(numberValue: Int, stringValue: String) = when (numberValue){\n    parseInt(stringValue) ->  \"stringValue holds the same number as numberValue\"\n    else -> \"stringValue is not the same number as numberValue\"\n}\n\nfun printInferredType(){\n    val number = 3\n    when(number){\n        is Int -> println (\"My inferred type is Int\")\n    }\n}\n\nfun printAnimal(aString: String) = when {\n    aString.equals(\"Dog\") -> \"A dog\"\n    aString.equals(\"Cat\") -> \"A cat\"\n    aString.contains(\"pig\") -> \"A pig of some sort\"\n    aString.length == 0 -> \"Empty String..no Animal\"\n    else -> \"No identifiable animal\"\n}\n\nfun describe(obj: Any): String = when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n}\n\n\nfun forEachStandard(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items){\n        println(\"Item is: \" + item)\n    }\n}\n\nfun forEachIndices(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (index in items.indices){\n        println(\"Item at \" + index + \" is: \" + items[index])\n    }\n}\n\nfun forEachWithIndex(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for ((index, value) in items.withIndex()){\n        println(\"The item at \" + index + \" is: \" + value)\n    }\n}\n~~~\n\n"
    },
  
    {
    "title": "# while",
    "shortTitle": "05",
    "contentMd" : "# while\n\nThe while and do-while are pretty much the same as Java.\n\n\n##while loop\n\nAdd the following method to your main class:\n\n~~~\nfun whileWithList(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    var index = 0\n    while (index < items.size){\n        println (\"Item at index: \" + index + \" is: \" +  items[index])\n        index++\n    }\n}\n~~~\n\nAnd call it by including this statement as the last statement in the *main* function:\n\n~~~\nwhileWithList()\n~~~\n\nWhen run, the last few lines of the console output should now be:\n\n> *Item at index: 0 is: apple*\n\n> *Item at index: 1 is: banana*\n\n> *Item at index: 2 is: kiwi*\n\n\n##do-while loop\n\nAdd the following method to your main class:\n\n~~~\nfun doWhileExample(){\n    var index = 0\n    do {\n        println(\"Do While Index is: \" + index)\n        index++\n    } while (index < 5)\n}\n~~~\n\nAnd call it by including this statement as the last statement in the *main* function:\n\n~~~\n  doWhileExample()\n~~~\n\nWhen run, the last few lines of the console output should now be:\n\n\n> *Do While Index is: 0*\n\n> *Do While Index is: 1*\n\n> *Do While Index is: 2*\n\n> *Do While Index is: 3*\n\n> *Do While Index is: 4*\n\n\nSave your work and keep the project open.\n\n\n##Solution - so far\n\nIf you need it, the completed code so far is here:\n\n~~~\nimport java.lang.Integer.parseInt\n\nfun main(args: Array<String>) {\n    println(\"The max number is: \" + maxOf(4, 6))\n    println(printValue(7))\n    printRange(30)\n    println(printExpressionResult(12, \"12\"))\n    printInferredType()\n    println(printAnimal(\"elephant\"))\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n\n    //for loop\n    forEachStandard()\n    forEachIndices()\n    forEachWithIndex()\n    whileWithList()\n    doWhileExample()\n}\n\n//if as an expression\nfun maxOf(a: Int, b: Int) =\n    if (a > b) {\n        print(\"a is greater than b.  \")\n        a\n    }else {\n        print(\"b is greater than a.  \")\n        b\n    }\n\n//when construct\nfun printValue(value : Int) = when(value) {\n    1 -> \"The value is One\"\n    2 -> \"The value is Two\"\n    in 3..5 -> \"The value is between Three and Five\"\n    6, 7, 8 -> \"The value is either Six, Seven or Eight\"\n    else -> \"The value is: \" + value\n}\n\nfun printRange(value: Int){\n    when(value){\n        in 1..10 -> println (\"Between 1..10\")\n        !in 10..20 -> println (\"Outside 10..20\")\n    }\n}\n\nfun printExpressionResult(numberValue: Int, stringValue: String) = when (numberValue){\n    parseInt(stringValue) ->  \"stringValue holds the same number as numberValue\"\n    else -> \"stringValue is not the same number as numberValue\"\n}\n\nfun printInferredType(){\n    val number = 3\n    when(number){\n        is Int -> println (\"My inferred type is Int\")\n    }\n}\n\nfun printAnimal(aString: String) = when {\n    aString.equals(\"Dog\") -> \"A dog\"\n    aString.equals(\"Cat\") -> \"A cat\"\n    aString.contains(\"pig\") -> \"A pig of some sort\"\n    aString.length == 0 -> \"Empty String..no Animal\"\n    else -> \"No identifiable animal\"\n}\n\nfun describe(obj: Any): String = when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n}\n\n\nfun forEachStandard(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items){\n        println(\"Item is: \" + item)\n    }\n}\n\nfun forEachIndices(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (index in items.indices){\n        println(\"Item at \" + index + \" is: \" + items[index])\n    }\n}\n\nfun forEachWithIndex(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for ((index, value) in items.withIndex()){\n        println(\"The item at \" + index + \" is: \" + value)\n    }\n}\n\nfun whileWithList(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    var index = 0\n    while (index < items.size){\n        println (\"Item at index: \" + index + \" is: \" +  items[index])\n        index++\n    }\n}\n\nfun doWhileExample(){\n    var index = 0\n    do {\n        println(\"Do While Index is: \" + index)\n        index++\n    } while (index < 5)\n}\n~~~\n\n"
    },
  
    {
    "title": "# Strings",
    "shortTitle": "06",
    "contentMd" : "# Strings\n\nKotlin has two types of string literals:\n\n- *escaped strings* that may have escaped characters in them and \n- *raw strings* that can contain newlines and arbitrary text. \n\n\n##escaped strings\n\nThese are very similar to Java strings.  Add the following function to your main class:\n\n~~~\nfun workingWithStrings(){\n    val aString = \"An escaped string!\\n\"\n    print(aString)\n}\n~~~\n\nAnd call it by including this statement as the last statement in the *main* function:\n\n~~~\n    whileWithStrings()\n~~~\n\nWhen run, the last line of the console output should now be:\n\n\n> *An escaped string!*\n\n\n##raw strings \n\nA raw string is delimited by a triple quote (\"\"\"), contains no escaping and can contain new lines and any other characters.\n\nUpdate the workingWithStrings function like so (declaring einstein variable and printing it out):\n\n~~~\nfun workingWithStrings(){\n    val aString = \"An escaped string!\\n\"\n    print(aString)\n\n    val einstein = \"\"\"\n        Learn from yesterday\n        Live for today\n        Hope for tomorrow\n        The important thing\n        is not to stop questioning.\n        (Albert Einstein)\n    \"\"\".trimIndent()\n    println(einstein)\n}\n~~~\n\nWhen run, the last lines of the console output should now be:\n\n> *Learn from yesterday*\n\n> *Live for today*\n\n> *Hope for tomorrow*\n\n> *The important thing*\n\n> *is not to stop questioning.*\n\n> *(Albert Einstein)*\n\n\nNow update the workingWithStrings function like so (declaring franklin variable and printing it out):\n\n~~~\nfun workingWithStrings(){\n    val aString = \"An escaped string!\\n\"\n    print(aString)\n\n    val einstein = \"\"\"\n        Learn from yesterday\n        Live for today\n        Hope for tomorrow\n        The important thing\n        is not to stop questioning.\n        (Albert Einstein)\n    \"\"\".trimIndent()\n    println(einstein)\n\n    val franklin = \"\"\"\n          |Tell me and I forget.\n          |Teach me and I remember.\n          |Involve me and I learn.\n          |  (Benjamin Franklin)\n    \"\"\".trimMargin()\n    println(franklin)\n}\n~~~\n\nWhen run, the last lines of the console output should now be (note how Benjamin Franklin is indented in your console):\n\n> *Tell me and I forget.*\n\n> *Teach me and I remember.*\n\n> *Involve me and I learn.*\n\n> *&nbsp;&nbsp;(Benjamin Franklin)*\n\n\nSave your work and keep the project open.\n\n"
    },
  
    {
    "title": "# String Templates",
    "shortTitle": "07",
    "contentMd" : "# String Templates\n\nStrings may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the String. \n\nA template expression starts with a dollar sign ($) and consists of either a:\n\n- simple name or\n- an arbitrary expression in curly braces\n\n\n##simple name\n\nYou should have this method in your main class (if you don't have it, cut and paste it in...and call it from the main function):\n\n~~~\nfun printValue(value : Int) = when(value) {\n    1 -> \"The value is One\"\n    2 -> \"The value is Two\"\n    in 3..5 -> \"The value is between Three and Five\"\n    6, 7, 8 -> \"The value is either Six, Seven or Eight\"\n    else -> \"The value is: \" + value\n}\n~~~\n\nWe are going to convert the *else* code into using a String template.   To do this, change the else code like so:\n\n~~~\n    else -> \"The value is: $value\"\n~~~\n\nNote how the *$value* is inside the double quotes.  Compare the way this is written with the previous way.\n\nLet's try it with another function.  You should have this code in your codebase:\n\n~~~\nfun forEachStandard(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items){\n        println(\"Item is: \" + item)\n    }\n}\n~~~\n\nChange the println statement to use String templates (note that IntelliJ is probably giving you a warning and ALT+Enter might change it for you automatically):\n\n~~~\n    println(\"Item is: $item\")\n~~~\n\nNow try use String templates in the println statement here:\n\n~~~\nfun forEachWithIndex(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for ((index, value) in items.withIndex()){\n        println(\"The item at \" + index + \" is: \" + value)\n    }\n}\n~~~\n\n\n##arbitrary expression\n\nTo demonstrate this construct, add this new function to your main class:\n\n~~~\nfun workingWithTemplates(){\n    var firstString = \"This is a String\"\n    var secondString = \"and this is another String\"\n\n    //using simple names\n    println (\"Simple names: $firstString $secondString\")\n\n    //using arbitrary expressions in {}\n    println(\"Expressions (cases): ${firstString.toUpperCase()} ${secondString.toLowerCase()}\")\n    println(\"Expressions (string size): first string is ${firstString.length}\")\n    println(\"Expressions (substring): ${firstString.substring(0,2)}\")\n}\n~~~\n\nAdd this function call as the last statement in your *main* function:\n\n~~~\n   workingWithTemplates()\n~~~\n\nThe last few statements in the console output should be:\n\n\n> *Simple names: This is a String and this is another String*\n\n> *Expressions (cases): THIS IS A STRING and this is another string*\n\n> *Expressions (string size): first string is 16*\n\n> *Expressions (substring): Th*\n\n\nSave your work and keep the project open.\n\n"
    },
  
    {
    "title": "# Null Safety",
    "shortTitle": "08",
    "contentMd" : "# Null Safety\n\nIn Kotlin, the type system distinguishes between references that can hold \nnull (nullable references) and those that cannot (non-null references).\n\nThe Kotlin compiler makes sure you don’t, by accident, operate on a variable that is null.\n\n\n##A non-null reference\n\nAdd a new function to your main class:\n\n~~~\nfun nullSafety() {\n    var aString = \"abc\"\n    val size = aString.length   //this is always going to have a reference\n    aString = null              //syntax error\n}\n~~~\n\nYou cannot set a non-null reference (i.e. our String) to a null.  This means that we cannot accidentally cause a null pointer exception.  \n\n\n##Nullable references\n\nBut what if we need to set our String to a null?  We will do this now by updating our variable declaration:\n\n~~~\nfun nullSafety() {\n    var aString :String? = \"abc\"\n    val size = aString.length   //now this is a syntax error\n    aString = null              //compiles\n}\n~~~\n\nNote that the *aString = null* statement compiles now, but we have caused a syntax error on line two of the function because variable *aString* can be null now. \n\nIf you need to have a *nullable reference* there are many ways around this.  \n\n\n##Option 1 (basic if statement)\n\nYou can explicitly check if *aString* is null, and handle the two options separately.  Try this now:\n\n~~~\nfun nullSafety() {\n    var aString :String? = \"abc\"\n    val size = if (aString != null) aString.length  else -1\n    aString = null              \n}\n~~~\n\n\n##Option 2 (safe call operator ?.)\n\nYou can use the safe call operator **?.**.  This returns aString.length if aString is not null, and null otherwise.  Try this now:\n\n~~~\nfun nullSafety() {\n    var aString :String? = \"abc\"\n    aString?.length \n    aString = null\n}\n~~~\n\n\n##Option 3 (not-null assertion operator)\n\nYou can use the **!!** Operator.  This forces a call to our function and will return a non-null value of aString or throw an Null Pointer Exception if aString is null.  Use sparingly!  Try this now:\n\n~~~\nfun nullSafety() {\n    var aString :String? = \"abc\"\n    aString!!.length\n    aString = null\n}\n~~~\n\n\n##Option 4 (Elvis operator)\n\nIf the expression to the left of the Elvis operator **?:** is not null, the elvis operator returns it, otherwise it returns the expression to the right. \n\nWe will use this now in our nullSafety() function:\n\n~~~\nfun nullSafety() {\n    var aString :String? = \"abc\"\n    val size = aString?.length ?: -1\n    aString = null\n}\n~~~\n\nSave your work and keep the project open.\n\n"
    },
  
    {
    "title": "#Exercises",
    "shortTitle": "Exercises",
    "contentMd" : "#Exercises\n\n\n## Exercise 1 (String Templates)\n\nThere are a few functions that could use String Templates.  Look through the code and update the println statements to use String Templates where possible.\n\n\n## Exercise 2: \n\nIf you have time to spare, try adding more functions and experiment with the constructs we covered in this lab and/or experiment with this kotlin learning resource:\n\n<https://kotlinlang.org/docs/tutorials/koans.html>\n\n"
    },
  
    {
    "title": "#Solution",
    "shortTitle": "Solution",
    "contentMd" : "#Solution\n\nShould you need it, the solution for the lab is here:\n\n~~~\nimport java.lang.Integer.parseInt\n\nfun main(args: Array<String>) {\n    println(\"The max number is: \" + maxOf(4, 6))\n    println(printValue(7))\n    printRange(30)\n    println(printExpressionResult(12, \"12\"))\n    printInferredType()\n    println(printAnimal(\"elephant\"))\n    println(describe(1))\n    println(describe(\"Hello\"))\n    println(describe(1000L))\n    println(describe(2))\n    println(describe(\"other\"))\n\n    //for loop\n    forEachStandard()\n    forEachIndices()\n    forEachWithIndex()\n    whileWithList()\n    doWhileExample()\n\n    //String Literals and Templates\n    workingWithStrings()\n    workingWithTemplates()\n    nullSafety()\n}\n\n//if as an expression\nfun maxOf(a: Int, b: Int) =\n    if (a > b) {\n        print(\"a is greater than b.  \")\n        a\n    }else {\n        print(\"b is greater than a.  \")\n        b\n    }\n\n//when construct\nfun printValue(value : Int) = when(value) {\n    1 -> \"The value is One\"\n    2 -> \"The value is Two\"\n    in 3..5 -> \"The value is between Three and Five\"\n    6, 7, 8 -> \"The value is either Six, Seven or Eight\"\n    else -> \"The value is: $value\"\n}\n\nfun printRange(value: Int){\n    when(value){\n        in 1..10 -> println (\"Between 1..10\")\n        !in 10..20 -> println (\"Outside 10..20\")\n    }\n}\n\nfun printExpressionResult(numberValue: Int, stringValue: String) = when (numberValue){\n    parseInt(stringValue) ->  \"stringValue holds the same number as numberValue\"\n    else -> \"stringValue is not the same number as numberValue\"\n}\n\nfun printInferredType(){\n    val number = 3\n    when(number){\n        is Int -> println (\"My inferred type is Int\")\n    }\n}\n\nfun printAnimal(aString: String) = when {\n    aString.equals(\"Dog\") -> \"A dog\"\n    aString.equals(\"Cat\") -> \"A cat\"\n    aString.contains(\"pig\") -> \"A pig of some sort\"\n    aString.length == 0 -> \"Empty String..no Animal\"\n    else -> \"No identifiable animal\"\n}\n\nfun describe(obj: Any): String = when (obj){\n        1 -> \"One\"\n        \"Hello\" -> \"A Greeting\"\n        is Long -> \"Long Var\"\n        !is String -> \"Not a String\"\n        else -> \"Unknown\"\n}\n\n\nfun forEachStandard(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (item in items){\n        println(\"Item is: $item\")\n    }\n}\n\nfun forEachIndices(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for (index in items.indices){\n        println(\"Item at $index is: $items[index]\")\n    }\n}\n\nfun forEachWithIndex(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    for ((index, value) in items.withIndex()){\n        println(\"The item at $index is: $value\")\n    }\n}\n\nfun whileWithList(){\n    val items = listOf(\"apple\", \"banana\", \"kiwi\")\n    var index = 0\n    while (index < items.size){\n        println (\"Item at index: $index is: ${items[index]}\")\n        index++\n    }\n}\n\nfun doWhileExample(){\n    var index = 0\n    do {\n        println(\"Do While Index is: $index\")\n        index++\n    } while (index < 5)\n}\n\n\nfun workingWithStrings(){\n    val aString = \"An escaped string!\\n\"\n    print(aString)\n\n    val einstein = \"\"\"\n        Learn from yesterday\n        Live for today\n        Hope for tomorrow\n        The important thing\n        is not to stop questioning.\n        (Albert Einstein)\n    \"\"\".trimIndent()\n    println(einstein)\n\n    val franklin = \"\"\"\n          |Tell me and I forget.\n          |Teach me and I remember.\n          |Involve me and I learn.\n          |  (Benjamin Franklin)\n    \"\"\".trimMargin()\n    println(franklin)\n}\n\nfun workingWithTemplates(){\n    var firstString = \"This is a String\"\n    var secondString = \"and this is another String\"\n\n    //using simple names\n    println (\"Simple names: $firstString $secondString\")\n\n    //using arbitrary expressions in {}\n    println(\"Expressions (cases): ${firstString.toUpperCase()} ${secondString.toLowerCase()}\")\n    println(\"Expressions (string size): first string is ${firstString.length}\")\n    println(\"Expressions (substring): ${firstString.substring(0,2)}\")\n}\n\nfun nullSafety() {\n    var aString :String? = \"abc\"\n    val size = aString?.length ?: -1\n    aString = null\n}\n~~~\n\n"
    }
  
  ]
  }

